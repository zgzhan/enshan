name: 恩山论坛自动签到 (增强诊断版)

on:
  schedule:
    - cron: '0 0 * * *' # 每天 UTC 0点 (北京时间 8点)
  workflow_dispatch:

jobs:
  sign:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout代码
        uses: actions/checkout@v3
      
      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: 安装依赖
        run: |
          # 安装Python依赖
          pip install playwright requests
          
          # 安装浏览器核心 (Chromium)
          playwright install chromium
          playwright install-deps chromium
      
      - name: 写入诊断脚本
        run: |
          cat << 'EOF' > enshan_playwright.py
# 粘贴 enshan_playwright_diagnostic.py 的全部内容到这里
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
恩山无线论坛自动签到脚本 (Playwright增强诊断版)
"""

import os
import re
import time
import random
import asyncio
import requests
import urllib3
from playwright.async_api import async_playwright

urllib3.disable_warnings()


class EnShanPlaywright:
    """恩山论坛自动签到类 (Playwright增强诊断版)"""
    
    name = "恩山无线论坛"
    
    def __init__(self):
        # 从环境变量获取配置
        self.cookie = os.getenv("ENSHAN_COOKIE")
        self.serverchan_key = os.environ.get('SERVERCHAN_KEY')
        self.page = None
        self.browser = None
        self.screenshot_path = "failure_screenshot.png" # 截图保存路径
        
    def parse_cookies(self):
        """解析Cookie字符串为列表"""
        cookies = []
        if not self.cookie:
            return cookies
            
        for item in self.cookie.split(';'):
            item = item.strip()
            if '=' in item:
                name, value = item.split('=', 1)
                cookies.append({
                    'name': name.strip(),
                    'value': value.strip(),
                    'domain': '.right.com.cn',
                    'path': '/'
                })
        
        return cookies
        
    def get_track(self, distance):
        """
        生成模拟人类滑动的轨迹
        :param distance: 需要滑动的距离
        :return: 轨迹列表
        """
        track = []
        current = 0
        mid = distance * 4 / 5
        t = 0.2
        v = 0
        
        while current < distance:
            if current < mid:
                a = 2  # 加速度
            else:
                a = -3  # 减速度
            
            v0 = v
            v = v0 + a * t
            move = v0 * t + 1 / 2 * a * t * t
            current += move
            track.append(round(move))
        
        # 添加随机抖动
        for _ in range(3):
            track.append(random.randint(-2, 2))
            
        return track
        
    async def solve_slider_captcha(self):
        """解决滑块验证码"""
        try:
            print("检测到验证码,正在尝试破解...")
            
            # 等待验证码加载
            await asyncio.sleep(3)
            
            # 尝试查找滑块元素 - 根据实际页面调整选择器
            slider_selectors = [
                '[class*="slider"]',
                '[class*="slide-verify"]',
                '.slide-verify-slider',
                '[class*="verify-slider"]',
                'div[style*="cursor"]'
            ]
            
            slider = None
            for selector in slider_selectors:
                try:
                    # 使用 page.query_selector 而不是 wait_for_selector, 避免长时间等待
                    slider = await self.page.query_selector(selector)
                    if slider:
                        print(f"找到滑块元素: {selector}")
                        break
                except:
                    continue
            
            # 默认使用坐标滑动 (更通用)
            # 验证码弹窗通常在页面中心,我们估算一个坐标
            start_x = 430
            start_y = 464
            
            if slider:
                # 如果找到滑块元素,使用元素中心坐标
                box = await slider.bounding_box()
                if box:
                    start_x = box['x'] + box['width'] / 2
                    start_y = box['y'] + box['height'] / 2
            
            await self.page.mouse.move(start_x, start_y)
            await self.page.mouse.down()
            await asyncio.sleep(0.2)
            
            # 生成滑动距离和轨迹
            # 恩山验证码的距离大约在 200-260 像素
            distance = random.randint(220, 260)
            track = self.get_track(distance)
            
            # 执行滑动
            current_x = start_x
            for move in track:
                current_x += move
                await self.page.mouse.move(
                    current_x,
                    start_y + random.randint(-2, 2)
                )
                await asyncio.sleep(random.uniform(0.01, 0.02))
            
            await asyncio.sleep(0.5)
            await self.page.mouse.up()
            
            # 等待验证结果
            await asyncio.sleep(3)
            
            # 检查是否验证成功
            content = await self.page.content()
            if "安全验证" in content or "Security Verification" in content:
                print("验证可能失败,需要重试")
                return False
            
            print("验证码破解成功")
            return True
            
        except Exception as e:
            print(f"滑块验证失败: {e}")
            return False
            
    async def sign_in(self):
        """执行签到"""
        try:
            async with async_playwright() as p:
                # 启动浏览器
                self.browser = await p.chromium.launch(
                    headless=True,
                    args=[
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-blink-features=AutomationControlled'
                    ]
                )
                
                # 创建上下文
                context = await self.browser.new_context(
                    viewport={'width': 1920, 'height': 1080},
                    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                )
                
                # 设置Cookie
                cookies = self.parse_cookies()
                if cookies:
                    await context.add_cookies(cookies)
                
                # 创建页面
                self.page = await context.new_page()
                
                # 访问签到页面
                print("正在访问签到页面...")
                await self.page.goto("https://www.right.com.cn/FORUM/erling_qd-sign_in.html", wait_until='networkidle')
                await asyncio.sleep(3)
                
                # 检查是否需要验证码
                content = await self.page.content()
                if "安全验证" in content or "Security Verification" in content:
                    # 尝试破解验证码,最多3次
                    for i in range(3):
                        print(f"第 {i+1} 次尝试破解验证码...")
                        if await self.solve_slider_captcha():
                            break
                        if i < 2:
                            await asyncio.sleep(2)
                            await self.page.reload()
                            await asyncio.sleep(3)
                
                # 等待页面加载
                await asyncio.sleep(3)
                
                # 尝试点击签到按钮
                sign_selectors = [
                    'button:has-text("签到")',
                    'a:has-text("签到")',
                    '[class*="sign"]',
                    '#sign_in'
                ]
                
                sign_button_clicked = False
                for selector in sign_selectors:
                    try:
                        buttons = await self.page.query_selector_all(selector)
                        if buttons:
                            await buttons[0].click()
                            print(f"点击签到按钮成功: {selector}")
                            sign_button_clicked = True
                            await asyncio.sleep(2)
                            break
                    except Exception as e:
                        print(f"尝试点击 {selector} 失败: {e}")
                        continue
                
                if not sign_button_clicked:
                    # 如果没有点击到任何按钮，可能是已经签到，或者页面结构变化
                    print("未找到可点击的签到按钮，尝试直接获取积分信息。")
                
                # 获取签到结果
                await asyncio.sleep(2)
                
                # 访问个人中心获取积分信息
                try:
                    print("正在访问个人中心获取积分信息...")
                    await self.page.goto("https://www.right.com.cn/FORUM/home.php?mod=spacecp&ac=credit&showcredit=1", wait_until='networkidle')
                    await asyncio.sleep(2)
                    
                    page_source = await self.page.content()
                    
                    coin_match = re.search(r"恩山币[:\s]*</em>([^&<]+)", page_source)
                    point_match = re.search(r"积分[:\s]*</em>([^<]+)", page_source)
                    
                    coin = coin_match.group(1).strip() if coin_match else "未知"
                    point = point_match.group(1).strip() if point_match else "未知"
                    
                    # 检查是否有签到成功的提示（虽然不准确，但作为辅助判断）
                    # 恩山论坛签到成功后，通常会跳转到积分页面，但没有明确的“签到成功”文字
                    # 我们主要依赖积分获取
                    
                    return {
                        "status": "success",
                        "coin": coin,
                        "point": point
                    }
                except Exception as e:
                    print(f"获取积分信息失败: {e}")
                    # 即使获取积分失败，也认为签到操作已完成
                    return {
                        "status": "success",
                        "message": "签到操作已执行,但无法获取详细积分信息"
                    }
                
        except Exception as e:
            # 发生任何异常时，进行截图
            if self.page:
                await self.page.screenshot(path=self.screenshot_path)
                print(f"发生异常，已保存截图到 {self.screenshot_path}")
            
            return {
                "status": "failed",
                "message": f"签到失败: {str(e)}"
            }
        finally:
            if self.browser:
                await self.browser.close()
                
    def push_notification(self, message):
        """推送通知到Server酱"""
        if not self.serverchan_key:
            return
            
        try:
            data = {
                'title': '恩山论坛签到结果',
                'desp': message,
            }
            response = requests.post(
                f'https://sctapi.ftqq.com/{self.serverchan_key}.send',
                data=data,
                timeout=10
            )
            if response.status_code == 200:
                print('推送成功')
            else:
                print(f'推送失败,状态码: {response.status_code}')
        except Exception as e:
            print(f'推送失败: {e}')
            
    def main(self):
        """主函数"""
        if not self.cookie:
            print("未找到恩山论坛的 Cookie,请设置 ENSHAN_COOKIE 环境变量。")
            return
        
        try:
            # 执行签到
            result = asyncio.run(self.sign_in())
            
            # 格式化消息
            if result["status"] == "success":
                if "coin" in result and result["coin"] != "未知":
                    msg = f"签到操作已执行。\n恩山币: {result['coin']}\n积分: {result['point']}"
                else:
                    msg = result.get("message", "签到操作已执行,但无法确认积分变动。")
            else:
                msg = result.get("message", "签到失败")
            
            # 推送通知
            if self.serverchan_key:
                self.push_notification(msg)
            
            # 打印结果，供GitHub Actions日志使用
            print(f"::set-output name=status::{result['status']}")
            print(f"::set-output name=message::{msg}")
            
            # 如果失败，则打印截图路径
            if result["status"] == "failed" and os.path.exists(self.screenshot_path):
                print(f"::set-output name=screenshot_path::{self.screenshot_path}")
            
            print(msg)
            
        except Exception as e:
            error_msg = f"执行出错: {str(e)}"
            if self.serverchan_key:
                self.push_notification(error_msg)
            print(error_msg)


if __name__ == "__main__":
    EnShanPlaywright().main()
EOF
      
      - name: 执行签到脚本
        env:
          ENSHAN_COOKIE: ${{ secrets.ENSHAN_COOKIE }}
          SERVERCHAN_KEY: ${{ secrets.SERVERCHAN_KEY }}
        run: |
          python enshan_playwright.py
      
      - name: 上传诊断截图
        uses: actions/upload-artifact@v3
        if: always() && steps.run_script.outputs.status == 'failed'
        with:
          name: failure-screenshot
          path: ${{ steps.run_script.outputs.screenshot_path }}
          retention-days: 7
